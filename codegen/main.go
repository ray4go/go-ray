package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/token"
	"go/types"
	"log"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	"golang.org/x/tools/go/packages"
	"golang.org/x/tools/imports"
)

const (
	workspaceRepo     = "github.com/ray4go/go-ray"
	raytasksComment   = "// raytasks"
	generatedFileName = "ray_workloads_wrapper.go"
)

const packageCommentsTPL = `
// Code generated by goray. DO NOT EDIT.
//
// This file was generated by goray.
// It contains wrappers for the ray tasks and actors in this package.
//
// To regenerate this file, run:
//
//	go run %s/codegen <package-path>
//
`

func main() {
	if len(os.Args) < 2 {
		fmt.Printf("Usage: go run %s/codegen <package-path>\n", workspaceRepo)
		os.Exit(1)
	}

	packagePath := os.Args[1]

	// Load the package
	cfg := &packages.Config{
		Mode: packages.NeedName | packages.NeedFiles | packages.NeedSyntax |
			packages.NeedTypes | packages.NeedTypesInfo | packages.NeedImports,
	}

	pkgs, err := packages.Load(cfg, packagePath)
	if err != nil {
		log.Fatal(err)
	}

	if len(pkgs) == 0 {
		log.Fatal("No packages found")
	}

	pkg := pkgs[0]
	if pkg.Errors != nil {
		for _, err := range pkg.Errors {
			log.Printf("Package error: %v", err)
		}
	}

	// Find struct with // raytasks comment
	var targetStruct *ast.TypeSpec
	var structFile *ast.File

	for _, file := range pkg.Syntax {
		ast.Inspect(file, func(n ast.Node) bool {
			if targetStruct != nil {
				return false
			}

			genDecl, ok := n.(*ast.GenDecl)
			if !ok || genDecl.Tok != token.TYPE {
				return true
			}

			// Check if there's a comment with $raytasksComment
			if genDecl.Doc != nil {
				for _, comment := range genDecl.Doc.List {
					if strings.TrimSpace(comment.Text) == raytasksComment {
						for _, spec := range genDecl.Specs {
							if typeSpec, ok := spec.(*ast.TypeSpec); ok {
								if _, ok := typeSpec.Type.(*ast.StructType); ok {
									targetStruct = typeSpec
									structFile = file
									return false
								}
							}
						}
					}
				}
			}

			return true
		})
	}

	if targetStruct == nil {
		log.Fatalf("No struct with '%s' comment found\n", raytasksComment)
	}

	fmt.Printf("Found raytasks struct: %s\n", targetStruct.Name.Name)

	// Find all methods for this struct
	methods := findMethods(pkg, targetStruct.Name.Name)

	// Generate wrapper code
	code := generateWrapperCode(pkg.Name, targetStruct.Name.Name, methods, pkg, structFile)

	// Format the generated code
	formatted, err := format.Source([]byte(code))
	if err != nil {
		log.Printf("Warning: Could not format generated code: %v", err)
		formatted = []byte(code)
	}

	outputFile := filepath.Join(packagePath, generatedFileName)
	// import 优化, 自动添加缺少的 import
	formatted, err = imports.Process(outputFile, formatted, nil)
	if err != nil {
		log.Fatalf("failed to process imports: %v", err)
	}

	// Write to file
	err = os.WriteFile(outputFile, formatted, 0644)
	if err != nil {
		log.Fatal(err)
	}

	fmt.Printf("Generated wrapper code written to: %s\n", outputFile)
}

type Method struct {
	ReceiverType string
	Name         string
	Params       []Param
	Results      []Result
	IsVariadic   bool
}

type Param struct {
	Name string
	Type string
}

type Result struct {
	Type string
}

func findMethods(pkg *packages.Package, structName string) []Method {
	var methods []Method

	// Get the struct type
	obj := pkg.Types.Scope().Lookup(structName)
	if obj == nil {
		return methods
	}

	named, ok := obj.Type().(*types.Named)
	if !ok {
		return methods
	}

	// Iterate through all methods
	for i := 0; i < named.NumMethods(); i++ {
		method := named.Method(i)
		if !method.Exported() {
			continue
		}

		sig := method.Type().(*types.Signature)
		m := Method{
			Name: method.Name(),
		}
		// fmt.Printf("method: %v Name: %v\n", method, method.Pkg())
		// fmt.Printf("sig.Recv: %v \n", sig.Recv())
		receiverType := sig.Recv().Type()

		// To get just the "*MyTask" part:
		// If it's a pointer, dereference it to get the named type
		receiverTypeStr := ""
		if ptr, ok := receiverType.(*types.Pointer); ok {
			if named, ok := ptr.Elem().(*types.Named); ok {
				receiverTypeStr = fmt.Sprintf("*%s", named.Obj().Name())
			}
		} else if named, ok := receiverType.(*types.Named); ok {
			// If it's not a pointer, it's already the named type
			receiverTypeStr = named.Obj().Name()
		}
		m.ReceiverType = receiverTypeStr

		// Process parameters
		params := sig.Params()
		for j := 0; j < params.Len(); j++ {
			param := params.At(j)
			paramType := types.TypeString(param.Type(), types.RelativeTo(pkg.Types))

			paramName := param.Name()
			if paramName == "" {
				paramName = fmt.Sprintf("arg%d", j)
			}

			m.Params = append(m.Params, Param{
				Name: paramName,
				Type: paramType,
			})
		}

		// Check if the last parameter is variadic
		if sig.Variadic() {
			m.IsVariadic = true
		}

		// Process results
		results := sig.Results()
		for j := 0; j < results.Len(); j++ {
			result := results.At(j)
			m.Results = append(m.Results, Result{
				Type: types.TypeString(result.Type(), types.RelativeTo(pkg.Types)),
			})
		}

		methods = append(methods, m)
	}

	return methods
}

func generateWrapperCode(packageName, structName string, methods []Method, pkg *packages.Package, structFile *ast.File) string {
	var buf bytes.Buffer

	// Package comments
	fmt.Fprintf(&buf, packageCommentsTPL, workspaceRepo)

	// Package declaration
	fmt.Fprintf(&buf, "package %s\n\n", packageName)

	// Collect and write imports
	// imports := collectImports(methods, pkg, structFile)
	imports := make(map[string]bool)
	// Add goray generic import
	imports[fmt.Sprintf(`. "%s/ray/generic"`, workspaceRepo)] = true
	if len(imports) > 0 {
		fmt.Fprintf(&buf, "import (\n")
		for imp := range imports {
			fmt.Fprintf(&buf, "\t%s\n", imp)
		}
		fmt.Fprintf(&buf, ")\n\n")
	}

	// Global client variable
	// fmt.Fprintf(&buf, "var client %s\n\n", structName)

	// Generate wrapper functions
	for _, method := range methods {
		generateWrapperFunction(&buf, method)
	}

	return buf.String()
}

func collectImports(methods []Method, pkg *packages.Package, structFile *ast.File) map[string]bool {
	imports := make(map[string]bool)

	// Add imports from the original file
	for _, imp := range structFile.Imports {
		path := strings.Trim(imp.Path.Value, `"`)
		if imp.Name != nil && imp.Name.Name != "" && imp.Name.Name != "_" {
			imports[fmt.Sprintf(`%s "%s"`, imp.Name.Name, path)] = true
		} else {
			imports[fmt.Sprintf(`"%s"`, path)] = true
		}
	}

	return imports
}

const funcDefTpl = `
func {{.FuncName}}({{.ParamList}}) *RemoteFunc[*Future{{.ResLen}}{{.ResTypes}}] {
	_ = ({{.ReceiverType}}).{{.FuncName}}  // help you to find the original method
	return NewRemoteFunc[*Future{{.ResLen}}{{.ResTypes}}](
		"{{.FuncName}}",
		{{.ArgsStatement}},
	)
}
`

type FuncDef struct {
	FuncName      string
	ParamList     string
	ResLen        int
	ResTypes      string
	ArgsStatement string
	ReceiverType  string
}

func generateWrapperFunction(buf *bytes.Buffer, method Method) {
	paramNames := make([]string, len(method.Params))
	paramList := ""
	for i, param := range method.Params {
		if i > 0 {
			paramList += ", "
		}
		paramNames[i] = param.Name
		if i == len(method.Params)-1 && method.IsVariadic {
			// For variadic parameter, we need to remove the [] prefix
			variadicType := param.Type
			if strings.HasPrefix(variadicType, "[]") {
				variadicType = strings.TrimPrefix(variadicType, "[]")
			}
			paramList += fmt.Sprintf("%s ...%s", param.Name, variadicType)
		} else {
			paramList += fmt.Sprintf("%s %s", param.Name, param.Type)
		}
	}

	resTypes := make([]string, len(method.Results))
	for i, res := range method.Results {
		resTypes[i] = res.Type
	}
	resTypesStr := ""
	if len(resTypes) > 0 {
		resTypesStr = fmt.Sprintf("[%s]", strings.Join(resTypes, ", "))
	}

	argsStatement := fmt.Sprintf("[]any{%s}", strings.Join(paramNames, ", "))
	if method.IsVariadic {
		argsStatement = fmt.Sprintf(
			"ExtendArgs([]any{%s}, %s)",
			strings.Join(paramNames[:len(paramNames)-1], ", "),
			paramNames[len(paramNames)-1],
		)
	}

	funcDef := FuncDef{
		FuncName:      method.Name,
		ParamList:     paramList,
		ResLen:        len(method.Results),
		ResTypes:      resTypesStr,
		ArgsStatement: argsStatement,
		ReceiverType:  method.ReceiverType,
	}

	tmpl, err := template.New("funcDef").Parse(funcDefTpl)
	if err != nil {
		panic(err)
	}
	err = tmpl.Execute(buf, funcDef)
	if err != nil {
		panic(err)
	}
}
