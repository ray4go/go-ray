package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/token"
	"go/types"
	"log"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"text/template"

	"golang.org/x/tools/go/packages"
	"golang.org/x/tools/imports"
)

const (
	workspaceRepo     = "github.com/ray4go/go-ray"
	raytasksComment   = "// raytasks"
	rayactorsComment  = "// rayactors"
	generatedFileName = "ray_workloads_wrapper.go"
)

const packageCommentsTPL = `
// Code generated by goray. DO NOT EDIT.
//
// This file was generated by goray.
// It contains wrappers for the ray tasks and actors in this package.
//
// To regenerate this file, run:
//	  goraygen <package-path>
`

func main() {
	if len(os.Args) < 2 {
		fmt.Printf("Usage: goraygen <package-path>\n")
		os.Exit(1)
	}
	packagePath := os.Args[1]
	absTargetDir, err := filepath.Abs(packagePath)
	if err != nil {
		log.Fatalf("Failed to get absolute path for %s: %v", packagePath, err)
	}

	// Load the package
	cfg := &packages.Config{
		Dir:  absTargetDir,
		Mode: packages.NeedName | packages.NeedFiles | packages.NeedSyntax | packages.NeedTypes,
	}

	// "./..." 表示加载指定目录及其所有子目录下的所有包
	// "./" 表示只加载该目录下的包（不包括子目录）
	pkgPattern := "./"
	pkgs, err := packages.Load(cfg, pkgPattern)
	if err != nil {
		log.Fatal(err)
	}

	if len(pkgs) == 0 {
		log.Fatal("No packages found")
	}

	pkg := pkgs[0]
	if pkg.Errors != nil {
		for _, err := range pkg.Errors {
			log.Printf("Package error: %v", err)
		}
	}

	typeConstraints := TypeConstraints{
		type2ConstraintId: make(map[string]int),
	}

	// Find struct with // raytasks comment
	var taskHolderStruct = findStruct(pkg, raytasksComment)
	var tasks []Method
	var taskImports map[string]struct{}
	if taskHolderStruct == nil {
		fmt.Printf("No struct with '%s' comment found\n", raytasksComment)
	} else {
		fmt.Printf("Found raytasks struct: %s\n", taskHolderStruct.Name.Name)
		tasks, taskImports = findMethods(pkg, taskHolderStruct.Name.Name)
	}

	var actorHolderStruct = findStruct(pkg, rayactorsComment)
	var actorFactories []Method
	var actorImports map[string]struct{}
	if actorHolderStruct == nil {
		fmt.Printf("No struct with '%s' comment found\n", rayactorsComment)
	} else {
		fmt.Printf("Found rayactors struct: %s\n", actorHolderStruct.Name.Name)
		actorFactories, actorImports = findMethods(pkg, actorHolderStruct.Name.Name)
	}

	typeConstraints.add(tasks)
	typeConstraints.add(actorFactories)
	importsList := []map[string]struct{}{taskImports, actorImports}

	actor2Methods := make(map[string][]Method)
	for _, actorFactory := range actorFactories {
		actorTypeName := actorFactory.Results[0].Type
		actorName := strings.TrimPrefix(actorTypeName, "*")
		actorMethods, imports_ := findMethods(pkg, actorName)
		typeConstraints.add(actorMethods)
		fmt.Printf("Actor %s methods: %d\n", actorName, len(actorMethods))
		actor2Methods[actorTypeName] = actorMethods
		importsList = append(importsList, imports_)
	}

	var buf bytes.Buffer
	// Package comments
	fmt.Fprintf(&buf, packageCommentsTPL)
	// Package declaration
	fmt.Fprintf(&buf, "package %s\n\n", pkg.Name)

	writeImports(&buf, importsList)

	// Generate wrapper functions
	for _, method := range tasks {
		generateWrapperFunction(taskDefTpl, &buf, method, typeConstraints.type2ConstraintId, "")
	}
	for _, method := range actorFactories {
		actorTypeName := method.Results[0].Type
		actorName := method.Name
		generateWrapperFunction(actorDefTpl, &buf, method, typeConstraints.type2ConstraintId, actorName)
		actorMethods := actor2Methods[actorTypeName]
		for _, actorMethod := range actorMethods {
			generateWrapperFunction(actorMethodDefTpl, &buf, actorMethod, typeConstraints.type2ConstraintId, actorName)
		}
	}

	buf.WriteString(typeConstraints.buf.String())

	code := buf.String()

	os.WriteFile("/tmp/out.go", []byte(code), 0644)

	// Format the generated code
	formatted, err := format.Source([]byte(code))
	if err != nil {
		log.Printf("Warning: Could not format generated code: %v", err)
		formatted = []byte(code)
	}

	outputFile := filepath.Join(packagePath, generatedFileName)
	// import 优化, 自动添加缺少的 import
	formatted, err = imports.Process(outputFile, formatted, nil)
	if err != nil {
		log.Fatalf("failed to process imports: %v", err)
	}

	// Write to file
	err = os.WriteFile(outputFile, formatted, 0644)
	if err != nil {
		log.Fatal(err)
	}

	fmt.Printf("Generated wrapper code written to: %s\n", outputFile)
}

func findStruct(pkg *packages.Package, commentPatten string) *ast.TypeSpec {
	var targetStruct *ast.TypeSpec
	for _, file := range pkg.Syntax {
		ast.Inspect(file, func(n ast.Node) bool {
			if targetStruct != nil {
				return false
			}

			genDecl, ok := n.(*ast.GenDecl)
			if !ok || genDecl.Tok != token.TYPE {
				return true
			}

			// Check if there's a comment with $raytasksComment
			if genDecl.Doc != nil {
				for _, comment := range genDecl.Doc.List {
					if strings.TrimSpace(comment.Text) == commentPatten {
						for _, spec := range genDecl.Specs {
							if typeSpec, ok := spec.(*ast.TypeSpec); ok {
								if _, ok := typeSpec.Type.(*ast.StructType); ok {
									targetStruct = typeSpec
									return false
								}
							}
						}
					}
				}
			}
			return true
		})
	}
	return targetStruct
}

func writeImports(buf *bytes.Buffer, imports []map[string]struct{}) {
	// Collect and write imports
	importSet := make(map[string]struct{})
	importSet[fmt.Sprintf(`"%s/ray"`, workspaceRepo)] = struct{}{}
	importSet[fmt.Sprintf(`. "%s/ray/generic"`, workspaceRepo)] = struct{}{}
	for _, imp := range imports {
		for imp := range imp {
			importSet[imp] = struct{}{}
		}
	}

	if len(importSet) > 0 {
		fmt.Fprintf(buf, "import (\n")
		for imp := range importSet {
			fmt.Fprintf(buf, "\t%s\n", imp)
		}
		fmt.Fprintf(buf, ")\n\n")
	}
}

type Method struct {
	ReceiverType string
	Name         string
	Params       []Param // for variadic, the last param.Type will be the slice element type
	Results      []Result
	IsVariadic   bool
}

type Param struct {
	Name string
	Type string
}

type Result struct {
	Type string
}

func findMethods(pkg *packages.Package, structName string) ([]Method, map[string]struct{}) {
	var methods []Method

	// Get the struct type
	obj := pkg.Types.Scope().Lookup(structName)
	if obj == nil {
		return methods, nil
	}

	named, ok := obj.Type().(*types.Named)
	if !ok {
		return methods, nil
	}

	imports := make(map[string]struct{})
	getTypeName := func(typ types.Type) string {
		pkgPath, typeName := GetPackageAndTypeName(typ)
		if pkgPath != pkg.Types.Path() && len(pkgPath) > 0 {
			imports[fmt.Sprintf(`"%s"`, pkgPath)] = struct{}{}
			typeName = fmt.Sprintf("%s.%s", packageName(pkgPath), typeName)
		}
		return typeName
	}
	// Iterate through all methods
	for i := 0; i < named.NumMethods(); i++ {
		method := named.Method(i)
		if !method.Exported() {
			continue
		}

		sig := method.Type().(*types.Signature)
		m := Method{
			Name: method.Name(),
		}
		// fmt.Printf("method: %v Name: %v\n", method, method.Pkg())
		// fmt.Printf("sig.Recv: %v \n", sig.Recv())
		receiverType := sig.Recv().Type()

		// To get just the "*MyTask" part:
		// If it's a pointer, dereference it to get the named type
		receiverTypeStr := ""
		if ptr, ok := receiverType.(*types.Pointer); ok {
			if named, ok := ptr.Elem().(*types.Named); ok {
				receiverTypeStr = fmt.Sprintf("*%s", named.Obj().Name())
			}
		} else if named, ok := receiverType.(*types.Named); ok {
			// If it's not a pointer, it's already the named type
			receiverTypeStr = named.Obj().Name()
		}
		m.ReceiverType = receiverTypeStr

		// Process parameters
		params := sig.Params()
		for j := 0; j < params.Len(); j++ {
			param := params.At(j)

			paramName := param.Name()
			if paramName == "" {
				paramName = fmt.Sprintf("arg%d", j)
			}

			//paramTypeName = types.TypeString(param.Type(), types.RelativeTo(pkg.Types))
			typeName := getTypeName(param.Type())
			if j == params.Len()-1 && sig.Variadic() {
				// If the last parameter is variadic, remove the [] prefix
				typeName = strings.TrimPrefix(typeName, "[]")
			}
			m.Params = append(m.Params, Param{
				Name: paramName,
				Type: typeName,
			})
		}

		// Check if the last parameter is variadic
		m.IsVariadic = sig.Variadic()

		// Process results
		results := sig.Results()
		for j := 0; j < results.Len(); j++ {
			result := results.At(j)
			m.Results = append(m.Results, Result{
				Type: getTypeName(result.Type()),
			})
		}

		methods = append(methods, m)
	}

	return methods, imports
}

func packageName(pkgPath string) string {
	sep := "/"
	lastIndex := strings.LastIndex(pkgPath, sep)
	if lastIndex == -1 {
		// If separator not found, return the original string as the only element
		return pkgPath
	}
	return pkgPath[lastIndex+len(sep):]
}

// GetPackageAndTypeName 从 types.Type 变量中提取包名和类型名。
// 返回 (包名, 类型名)。如果类型没有显式的包名（例如基本类型或复合类型），包名将为空字符串。
func GetPackageAndTypeName(typ types.Type) (packageName string, typeName string) {
	// 首先检查是否是具名类型 (Named type)，这是最常见的情况，也是唯一有显式包名的情况。
	if named, ok := typ.(*types.Named); ok {
		obj := named.Obj() // 获取定义这个具名类型的 *types.TypeName 对象
		if obj != nil {
			// typeName 是这个类型的名称 (例如 "MyStruct", "Reader")
			typeName = obj.Name()
			// Package() 返回定义这个类型的包，如果类型是预声明的（如 int），则为 nil
			if obj.Pkg() != nil {
				packageName = obj.Pkg().Path() // 包的导入路径 (例如 "fmt", "main")
			}
		}
		return packageName, typeName
	}

	// 接下来处理其他类型的 *types.Type，它们本身没有包名，但有类型名。
	// 对于这些类型，packageName 将为空字符串。
	switch t := typ.(type) {
	case *types.Basic:
		// 基本类型 (int, string, bool 等)
		typeName = t.Name()
		if t.Kind() == types.UnsafePointer {
			packageName = "unsafe"
		}
	case *types.Pointer:
		// 指针类型 (*int, *MyStruct)
		// 类型名是 "ptrTo" + 元素类型名
		// 如果需要更精确的表示，可以递归调用 GetPackageAndTypeName(t.Elem())
		_, elemTypeName := GetPackageAndTypeName(t.Elem())
		typeName = "*" + elemTypeName
	case *types.Slice:
		// 切片类型 ([]int, []MyStruct)
		_, elemTypeName := GetPackageAndTypeName(t.Elem())
		typeName = "[]" + elemTypeName
	case *types.Array:
		// 数组类型 ([N]int, [N]MyStruct)
		_, elemTypeName := GetPackageAndTypeName(t.Elem())
		typeName = fmt.Sprintf("[%d]%s", t.Len(), elemTypeName)
	case *types.Map:
		// 映射类型 (map[string]int)
		_, keyTypeName := GetPackageAndTypeName(t.Key())
		_, elemTypeName := GetPackageAndTypeName(t.Elem())
		typeName = fmt.Sprintf("map[%s]%s", keyTypeName, elemTypeName)
	case *types.Chan:
		// 通道类型 (chan int, chan<- bool)
		_, elemTypeName := GetPackageAndTypeName(t.Elem())
		dir := ""
		switch t.Dir() {
		case types.SendRecv:
			dir = "chan "
		case types.SendOnly:
			dir = "chan<- "
		case types.RecvOnly:
			dir = "<-chan "
		}
		typeName = dir + elemTypeName
	case *types.Signature:
		// 函数或方法签名类型 (func(int) string)
		// 这通常只在需要打印完整的函数签名时有用。
		// 对于包名和类型名，它本身通常不具有一个独立的“名称”。
		// 如果需要表示，可以使用 t.String()。
		typeName = t.String()
	case *types.Struct:
		// 结构体字面量类型 (struct { Field int })
		// 类似于匿名结构体。
		typeName = t.String()
	case *types.Interface:
		// 接口字面量类型 (interface { Method() })
		// 类似于匿名接口。
		typeName = t.String()
	default:
		// 对于其他未知或不常见的类型，使用其 String() 方法作为名称
		typeName = typ.String()
	}

	return packageName, typeName
}

const typeConstraintTpl = `
type T%d interface {
	%s | *Future1[%s]
}
`

type TypeConstraints struct {
	buf               bytes.Buffer
	type2ConstraintId map[string]int
}

func (t *TypeConstraints) add(methods []Method) {
	for _, method := range methods {
		for _, param := range method.Params {
			if _, ok := t.type2ConstraintId[param.Type]; !ok {
				typeConstraintId := len(t.type2ConstraintId)
				typeConstraint := fmt.Sprintf(typeConstraintTpl, typeConstraintId, param.Type, param.Type)
				t.buf.WriteString(typeConstraint)
				t.type2ConstraintId[param.Type] = typeConstraintId
			}
		}
	}
}

/*
	func Echo[any_0 T2](args ...any_0) *RemoteFunc[*Future1[[]any]] {
		_ = (demo).Echo // help you to findStruct the original task
		return NewRemoteFunc[*Future1[[]any]]("Echo", ExpandArgs([]any{}, args))
	}
*/
const taskDefTpl = `
func {{.FuncName}} {{.TypeConstraints}} ( {{.ParamList}} ) *RemoteFunc[*Future{{.ResLen}}{{.ResTypes}}] {
	_ = ({{.ReceiverType}}).{{.FuncName}}  // help you to findStruct the original task
	return NewRemoteFunc[*Future{{.ResLen}}{{.ResTypes}}]("{{.FuncName}}", {{.ArgsStatement}})
}
`

const actorDefTpl = `
type Actor{{.ActorName}} ray.ActorHandle

func {{.FuncName}} {{.TypeConstraints}} ( {{.ParamList}} ) *RemoteActor[Actor{{.ActorName}}] {
	_ = ({{.ReceiverType}}).{{.FuncName}}  // help you to findStruct the original actor constructor
	return NewRemoteActor[Actor{{.ActorName}}]("{{.FuncName}}", []any{n})
}
`

const actorMethodDefTpl = `
func {{.FuncName}} {{.TypeConstraints}} (actor Actor{{.ActorName}}, {{.ParamList}}) *RemoteFunc[*Future{{.ResLen}}{{.ResTypes}}] {
	_ = ({{.ReceiverType}}).{{.FuncName}}  // help you to findStruct the original actor method
	return NewRemoteFunc[*Future{{.ResLen}}{{.ResTypes}}]("{{.FuncName}}", {{.ArgsStatement}}, ray.ActorHandle(actor))
}
`

type FuncDef struct {
	FuncName        string
	TypeConstraints string
	ParamList       string
	ResLen          int
	ResTypes        string
	ArgsStatement   string
	ReceiverType    string

	ActorName string // only for actor def
}

func generateWrapperFunction(tpl string, buf *bytes.Buffer, method Method, type2ConstraintId map[string]int, actorName string) {
	paramNames := make([]string, len(method.Params))
	paramList := make([]string, len(method.Params))
	typeConstraintList := make([]string, len(method.Params))
	for i, param := range method.Params {
		paramNames[i] = param.Name

		paramTypeName := typeFriendlyName(param.Type)
		paramTypeName = fmt.Sprintf("%s_%d", paramTypeName, i)
		typeConstraintList[i] = fmt.Sprintf("%s T%d", paramTypeName, type2ConstraintId[param.Type])

		if i == len(method.Params)-1 && method.IsVariadic {
			// For variadic parameter, we need to remove the [] prefix
			paramList[i] = fmt.Sprintf("%s ...%s", param.Name, paramTypeName)
		} else {
			paramList[i] = fmt.Sprintf("%s %s", param.Name, paramTypeName)
		}
	}
	typeConstraints := strings.Join(typeConstraintList, ", ")
	if len(typeConstraints) > 0 {
		typeConstraints = fmt.Sprintf("[%s]", typeConstraints)
	}

	resTypes := make([]string, len(method.Results))
	for i, res := range method.Results {
		resTypes[i] = res.Type
	}
	resTypesStr := ""
	if len(resTypes) > 0 { // Future0 has no generic type
		resTypesStr = fmt.Sprintf("[%s]", strings.Join(resTypes, ", "))
	}

	argsStatement := fmt.Sprintf("[]any{%s}", strings.Join(paramNames, ", "))
	if method.IsVariadic {
		argsStatement = fmt.Sprintf(
			"ExpandArgs([]any{%s}, %s)",
			strings.Join(paramNames[:len(paramNames)-1], ", "),
			paramNames[len(paramNames)-1],
		)
	}

	funcDef := FuncDef{
		FuncName:        method.Name,
		TypeConstraints: typeConstraints,
		ParamList:       strings.Join(paramList, ", "),
		ResLen:          len(method.Results),
		ResTypes:        resTypesStr,
		ArgsStatement:   argsStatement,
		ReceiverType:    method.ReceiverType,
		ActorName:       actorName,
	}

	tmpl, err := template.New("funcDef").Parse(tpl)
	if err != nil {
		panic(err)
	}
	err = tmpl.Execute(buf, funcDef)
	if err != nil {
		panic(err)
	}
}

// 将 Go 类型名转换为更友好的标识符名称
// 例如：[]T -> sliceOfT; *T -> pointerOfT; map[K]V -> mapK2V; [n]T -> arrNT; ...
func typeFriendlyName(typ string) string {
	// Handle pointer types
	typ = strings.ReplaceAll(typ, "*", "pointerOf")

	// Handle slice types
	typ = strings.ReplaceAll(typ, "[]", "sliceOf")

	// Handle array types [n]T -> arrNT
	arrayRegex := regexp.MustCompile(`\[(\d+)\]`)
	typ = arrayRegex.ReplaceAllString(typ, "arr${1}Of")

	// Handle map types map[K]V -> mapKToV
	mapRegex := regexp.MustCompile(`map\[([^\]]+)\](.*)`)
	typ = mapRegex.ReplaceAllString(typ, "map${1}To${2}")

	// Handle channel types
	typ = strings.ReplaceAll(typ, "chan<-", "sendChanOf")
	typ = strings.ReplaceAll(typ, "<-chan", "recvChanOf")
	typ = strings.ReplaceAll(typ, "chan ", "chanOf")

	// Handle function types (basic case)
	if strings.HasPrefix(typ, "func(") {
		typ = strings.ReplaceAll(typ, "func(", "funcWith")
		typ = strings.ReplaceAll(typ, ")", "")
	}

	// Handle interface{} -> any
	typ = strings.ReplaceAll(typ, "interface{}", "any")

	// Replace spaces and dots with underscores
	typ = strings.ReplaceAll(typ, " ", "_")
	typ = strings.ReplaceAll(typ, ".", "_")

	// only keep alphanumeric + '_' chars
	typ = regexp.MustCompile(`[^a-zA-Z0-9_]`).ReplaceAllString(typ, "")

	return typ
}
