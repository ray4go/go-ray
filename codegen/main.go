package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/token"
	"go/types"
	"log"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	"golang.org/x/tools/go/packages"
	"golang.org/x/tools/imports"
)

const (
	workspaceRepo     = "github.com/ray4go/go-ray"
	raytasksComment   = "// raytasks"
	generatedFileName = "ray_workloads_wrapper.go"
)

const packageCommentsTPL = `
// Code generated by goray. DO NOT EDIT.
//
// This file was generated by goray.
// It contains wrappers for the ray tasks and actors in this package.
//
// To regenerate this file, run:
//
//	goraygen <package-path>
//
`

func main() {
	if len(os.Args) < 2 {
		fmt.Printf("Usage: goraygen <package-path>\n")
		os.Exit(1)
	}
	packagePath := os.Args[1]
	absTargetDir, err := filepath.Abs(packagePath)
	if err != nil {
		log.Fatalf("Failed to get absolute path for %s: %v", packagePath, err)
	}

	// Load the package
	cfg := &packages.Config{
		Dir: absTargetDir,
		Mode: packages.NeedName | packages.NeedFiles | packages.NeedSyntax |
			packages.NeedTypes | packages.NeedTypesInfo | packages.NeedImports,
	}

	// "./..." 表示加载指定目录及其所有子目录下的所有包
	// "./" 表示只加载该目录下的包（不包括子目录）
	pkgPattern := "./"
	pkgs, err := packages.Load(cfg, pkgPattern)
	if err != nil {
		log.Fatal(err)
	}

	if len(pkgs) == 0 {
		log.Fatal("No packages found")
	}

	pkg := pkgs[0]
	if pkg.Errors != nil {
		for _, err := range pkg.Errors {
			log.Printf("Package error: %v", err)
		}
	}

	// Find struct with // raytasks comment
	var targetStruct *ast.TypeSpec
	var structFile *ast.File

	for _, file := range pkg.Syntax {
		ast.Inspect(file, func(n ast.Node) bool {
			if targetStruct != nil {
				return false
			}

			genDecl, ok := n.(*ast.GenDecl)
			if !ok || genDecl.Tok != token.TYPE {
				return true
			}

			// Check if there's a comment with $raytasksComment
			if genDecl.Doc != nil {
				for _, comment := range genDecl.Doc.List {
					if strings.TrimSpace(comment.Text) == raytasksComment {
						for _, spec := range genDecl.Specs {
							if typeSpec, ok := spec.(*ast.TypeSpec); ok {
								if _, ok := typeSpec.Type.(*ast.StructType); ok {
									targetStruct = typeSpec
									structFile = file
									return false
								}
							}
						}
					}
				}
			}

			return true
		})
	}

	if targetStruct == nil {
		log.Fatalf("No struct with '%s' comment found\n", raytasksComment)
	}

	fmt.Printf("Found raytasks struct: %s\n", targetStruct.Name.Name)

	// Find all methods for this struct
	methods, imports_ := findMethods(pkg, targetStruct.Name.Name)

	// Generate wrapper code
	code := generateWrapperCode(pkg.Name, targetStruct.Name.Name, methods, pkg, structFile, imports_)

	os.WriteFile("/tmp/out.go", []byte(code), 0644)

	// Format the generated code
	formatted, err := format.Source([]byte(code))
	if err != nil {
		log.Printf("Warning: Could not format generated code: %v", err)
		formatted = []byte(code)
	}

	outputFile := filepath.Join(packagePath, generatedFileName)
	// import 优化, 自动添加缺少的 import
	formatted, err = imports.Process(outputFile, formatted, nil)
	if err != nil {
		log.Fatalf("failed to process imports: %v", err)
	}

	// Write to file
	err = os.WriteFile(outputFile, formatted, 0644)
	if err != nil {
		log.Fatal(err)
	}

	fmt.Printf("Generated wrapper code written to: %s\n", outputFile)
}

type Method struct {
	ReceiverType string
	Name         string
	Params       []Param
	Results      []Result
	IsVariadic   bool
}

type Param struct {
	Name string
	Type string
}

type Result struct {
	Type string
}

func findMethods(pkg *packages.Package, structName string) ([]Method, map[string]struct{}) {
	var methods []Method

	// Get the struct type
	obj := pkg.Types.Scope().Lookup(structName)
	if obj == nil {
		return methods, nil
	}

	named, ok := obj.Type().(*types.Named)
	if !ok {
		return methods, nil
	}

	imports := make(map[string]struct{})
	// Iterate through all methods
	for i := 0; i < named.NumMethods(); i++ {
		method := named.Method(i)
		if !method.Exported() {
			continue
		}

		sig := method.Type().(*types.Signature)
		m := Method{
			Name: method.Name(),
		}
		// fmt.Printf("method: %v Name: %v\n", method, method.Pkg())
		// fmt.Printf("sig.Recv: %v \n", sig.Recv())
		receiverType := sig.Recv().Type()

		// To get just the "*MyTask" part:
		// If it's a pointer, dereference it to get the named type
		receiverTypeStr := ""
		if ptr, ok := receiverType.(*types.Pointer); ok {
			if named, ok := ptr.Elem().(*types.Named); ok {
				receiverTypeStr = fmt.Sprintf("*%s", named.Obj().Name())
			}
		} else if named, ok := receiverType.(*types.Named); ok {
			// If it's not a pointer, it's already the named type
			receiverTypeStr = named.Obj().Name()
		}
		m.ReceiverType = receiverTypeStr

		// Process parameters
		params := sig.Params()
		for j := 0; j < params.Len(); j++ {
			param := params.At(j)
			paramPkgPath, paramTypeName := GetPackageAndTypeName(param.Type())
			if paramPkgPath != pkg.Types.Path() && len(paramPkgPath) > 0 {
				imports[fmt.Sprintf(`"%s"`, paramPkgPath)] = struct{}{}
				paramTypeName = fmt.Sprintf("%s.%s", packageNmae(paramPkgPath), paramTypeName)
			}
			paramName := param.Name()
			if paramName == "" {
				paramName = fmt.Sprintf("arg%d", j)
			}

			m.Params = append(m.Params, Param{
				Name: paramName,
				Type: paramTypeName,
			})
		}

		// Check if the last parameter is variadic
		if sig.Variadic() {
			m.IsVariadic = true
		}

		// Process results
		results := sig.Results()
		for j := 0; j < results.Len(); j++ {
			result := results.At(j)
			m.Results = append(m.Results, Result{
				Type: types.TypeString(result.Type(), types.RelativeTo(pkg.Types)),
			})
		}

		methods = append(methods, m)
	}

	return methods, imports
}

func packageNmae(pkgPath string) string {
	sep := "/"
	lastIndex := strings.LastIndex(pkgPath, sep)
	if lastIndex == -1 {
		// If separator not found, return the original string as the only element
		return pkgPath
	}
	return pkgPath[lastIndex+len(sep):]
}

// GetPackageAndTypeName 从 types.Type 变量中提取包名和类型名。
// 返回 (包名, 类型名)。如果类型没有显式的包名（例如基本类型或复合类型），包名将为空字符串。
func GetPackageAndTypeName(typ types.Type) (packageName string, typeName string) {
	// 首先检查是否是具名类型 (Named type)，这是最常见的情况，也是唯一有显式包名的情况。
	if named, ok := typ.(*types.Named); ok {
		obj := named.Obj() // 获取定义这个具名类型的 *types.TypeName 对象
		if obj != nil {
			// typeName 是这个类型的名称 (例如 "MyStruct", "Reader")
			typeName = obj.Name()
			// Package() 返回定义这个类型的包，如果类型是预声明的（如 int），则为 nil
			if obj.Pkg() != nil {
				packageName = obj.Pkg().Path() // 包的导入路径 (例如 "fmt", "main")
			}
		}
		return packageName, typeName
	}

	// 接下来处理其他类型的 *types.Type，它们本身没有包名，但有类型名。
	// 对于这些类型，packageName 将为空字符串。
	switch t := typ.(type) {
	case *types.Basic:
		// 基本类型 (int, string, bool 等)
		typeName = t.Name()
	case *types.Pointer:
		// 指针类型 (*int, *MyStruct)
		// 类型名是 "ptrTo" + 元素类型名
		// 如果需要更精确的表示，可以递归调用 GetPackageAndTypeName(t.Elem())
		_, elemTypeName := GetPackageAndTypeName(t.Elem())
		typeName = "*" + elemTypeName
	case *types.Slice:
		// 切片类型 ([]int, []MyStruct)
		_, elemTypeName := GetPackageAndTypeName(t.Elem())
		typeName = "[]" + elemTypeName
	case *types.Array:
		// 数组类型 ([N]int, [N]MyStruct)
		_, elemTypeName := GetPackageAndTypeName(t.Elem())
		typeName = fmt.Sprintf("[%d]%s", t.Len(), elemTypeName)
	case *types.Map:
		// 映射类型 (map[string]int)
		_, keyTypeName := GetPackageAndTypeName(t.Key())
		_, elemTypeName := GetPackageAndTypeName(t.Elem())
		typeName = fmt.Sprintf("map[%s]%s", keyTypeName, elemTypeName)
	case *types.Chan:
		// 通道类型 (chan int, chan<- bool)
		_, elemTypeName := GetPackageAndTypeName(t.Elem())
		dir := ""
		switch t.Dir() {
		case types.SendRecv:
			dir = "chan "
		case types.SendOnly:
			dir = "chan<- "
		case types.RecvOnly:
			dir = "<-chan "
		}
		typeName = dir + elemTypeName
	case *types.Signature:
		// 函数或方法签名类型 (func(int) string)
		// 这通常只在需要打印完整的函数签名时有用。
		// 对于包名和类型名，它本身通常不具有一个独立的“名称”。
		// 如果需要表示，可以使用 t.String()。
		typeName = t.String()
	case *types.Struct:
		// 结构体字面量类型 (struct { Field int })
		// 类似于匿名结构体。
		typeName = t.String()
	case *types.Interface:
		// 接口字面量类型 (interface { Method() })
		// 类似于匿名接口。
		typeName = t.String()
	default:
		// 对于其他未知或不常见的类型，使用其 String() 方法作为名称
		typeName = typ.String()
	}

	return packageName, typeName
}

const typeDefTPL = `
type _rayTasks struct{}

var %sTasks = _rayTasks{}
`

func generateWrapperCode(packageName, structName string, methods []Method, pkg *packages.Package, structFile *ast.File, imports map[string]struct{}) string {
	var buf bytes.Buffer

	// Package comments
	fmt.Fprintf(&buf, packageCommentsTPL)

	// Package declaration
	fmt.Fprintf(&buf, "package %s\n\n", packageName)

	// Collect and write imports
	// imports := collectImports(methods, pkg, structFile)
	// Add goray generic import
	imports[fmt.Sprintf(`. "%s/ray/generic"`, workspaceRepo)] = struct{}{}
	if len(imports) > 0 {
		fmt.Fprintf(&buf, "import (\n")
		for imp := range imports {
			fmt.Fprintf(&buf, "\t%s\n", imp)
		}
		fmt.Fprintf(&buf, ")\n\n")
	}

	// Global client variable
	fmt.Fprintf(&buf, typeDefTPL, structName)

	// Generate wrapper functions
	for _, method := range methods {
		generateWrapperFunction(&buf, method)
	}

	return buf.String()
}

func collectImports(methods []Method, pkg *packages.Package, structFile *ast.File) map[string]bool {
	imports := make(map[string]bool)

	// Add imports from the original file
	for _, imp := range structFile.Imports {
		path := strings.Trim(imp.Path.Value, `"`)
		if imp.Name != nil && imp.Name.Name != "" && imp.Name.Name != "_" {
			imports[fmt.Sprintf(`%s "%s"`, imp.Name.Name, path)] = true
		} else {
			imports[fmt.Sprintf(`"%s"`, path)] = true
		}
	}

	return imports
}

const funcDefTpl = `
func (_ _rayTasks){{.FuncName}}({{.ParamList}}) *RemoteFunc[*Future{{.ResLen}}{{.ResTypes}}] {
	_ = ({{.ReceiverType}}).{{.FuncName}}  // help you to find the original method
	return NewRemoteFunc[*Future{{.ResLen}}{{.ResTypes}}]("{{.FuncName}}", []any{ {{.ParamNames}} })
}
`

type FuncDef struct {
	FuncName     string
	ParamList    string
	ResLen       int
	ResTypes     string
	ParamNames   string
	ReceiverType string
}

func generateWrapperFunction(buf *bytes.Buffer, method Method) {
	paramNames := make([]string, len(method.Params))
	paramList := ""
	for i, param := range method.Params {
		if i > 0 {
			paramList += ", "
		}
		paramNames[i] = param.Name
		if i == len(method.Params)-1 && method.IsVariadic {
			// For variadic parameter, we need to remove the [] prefix
			variadicType := param.Type
			if strings.HasPrefix(variadicType, "[]") {
				variadicType = strings.TrimPrefix(variadicType, "[]")
			}
			paramList += fmt.Sprintf("%s ...%s", param.Name, variadicType)
		} else {
			paramList += fmt.Sprintf("%s %s", param.Name, param.Type)
		}
	}

	resTypes := make([]string, len(method.Results))
	for i, res := range method.Results {
		resTypes[i] = res.Type
	}
	resTypesStr := ""
	if len(resTypes) > 0 { // Future0 has no generic type
		resTypesStr = fmt.Sprintf("[%s]", strings.Join(resTypes, ", "))
	}

	funcDef := FuncDef{
		FuncName:     method.Name,
		ParamList:    paramList,
		ResLen:       len(method.Results),
		ResTypes:     resTypesStr,
		ParamNames:   strings.Join(paramNames, ", "),
		ReceiverType: method.ReceiverType,
	}

	tmpl, err := template.New("funcDef").Parse(funcDefTpl)
	if err != nil {
		panic(err)
	}
	err = tmpl.Execute(buf, funcDef)
	if err != nil {
		panic(err)
	}
}
