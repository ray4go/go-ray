package main

import (
	"bytes"
	"errors"
	"fmt"
	"go/ast"
	"go/format"
	"go/token"
	"go/types"
	"log"
	"os"
	"path/filepath"
	"regexp"
	"sort"
	"strings"
	"text/template"

	"golang.org/x/tools/go/packages"
	"golang.org/x/tools/imports"
)

const (
	workspaceRepo     = "github.com/ray4go/go-ray"
	raytasksComment   = "// raytasks"
	rayactorsComment  = "// rayactors"
	generatedFileName = "ray_workloads_wrapper.go"
)

const packageCommentsTPL = `
// Code generated by goray. DO NOT EDIT.
//
// This file was generated by goray.
// It contains wrappers for the ray tasks and actors in this package.
//
// To regenerate this file, run:
//	  goraygen <package-path>
`

func main() {
	if len(os.Args) < 2 {
		fmt.Printf("Usage: goraygen <package-path>\n")
		os.Exit(1)
	}
	g, err := NewGenerator(os.Args[1])
	if err != nil {
		log.Fatal(err)
	}
	if err := g.Run(); err != nil {
		log.Fatal(err)
	}
}

// Generator encapsulates state & steps for code generation.
type Generator struct {
	packagePath string
	absDir      string
	pkg         *packages.Package

	tasks          []Method
	taskImports    map[string]struct{}
	actorFactories []Method
	actorImports   map[string]struct{}
	actor2Methods  map[string][]Method // key: actor type (*X)

	typeConstraints TypeConstraints
}

func NewGenerator(packagePath string) (*Generator, error) {
	absTargetDir, err := filepath.Abs(packagePath)
	if err != nil {
		return nil, fmt.Errorf("get abs path: %w", err)
	}
	return &Generator{
		packagePath:     packagePath,
		absDir:          absTargetDir,
		actor2Methods:   make(map[string][]Method),
		typeConstraints: TypeConstraints{type2ConstraintId: make(map[string]int)},
	}, nil
}

func (g *Generator) Run() error { // orchestrates phases
	if err := g.loadPackage(); err != nil {
		return err
	}
	g.collectWorkloads()
	g.collectActorMethods()
	code := g.generateCode()
	if err := g.write(code); err != nil {
		return err
	}
	return nil
}

func (g *Generator) loadPackage() error {
	cfg := &packages.Config{
		Dir:  g.absDir,
		Mode: packages.NeedName | packages.NeedFiles | packages.NeedSyntax | packages.NeedTypes,
	}
	pkgs, err := packages.Load(cfg, "./")
	if err != nil {
		return err
	}
	if len(pkgs) == 0 {
		return errors.New("no packages found")
	}
	g.pkg = pkgs[0]
	if g.pkg.Errors != nil {
		for _, e := range g.pkg.Errors {
			log.Printf("Package error: %v", e)
		}
	}
	return nil
}

func (g *Generator) collectWorkloads() {
	// tasks
	if s := findStruct(g.pkg, raytasksComment); s != nil {
		fmt.Printf("Found raytasks struct: %s\n", s.Name.Name)
		g.tasks, g.taskImports = findMethods(g.pkg, s.Name.Name)
		g.typeConstraints.add(g.tasks)
	} else {
		fmt.Printf("No struct with '%s' comment found\n", raytasksComment)
	}
	// actors
	if s := findStruct(g.pkg, rayactorsComment); s != nil {
		fmt.Printf("Found rayactors struct: %s\n", s.Name.Name)
		g.actorFactories, g.actorImports = findMethods(g.pkg, s.Name.Name)
		g.typeConstraints.add(g.actorFactories)
	} else {
		fmt.Printf("No struct with '%s' comment found\n", rayactorsComment)
	}
}

func (g *Generator) collectActorMethods() {
	for _, actorFactory := range g.actorFactories {
		if len(actorFactory.Results) == 0 {
			continue // defensive
		}
		actorTypeName := actorFactory.Results[0].Type
		actorName := strings.TrimPrefix(actorTypeName, "*")
		actorMethods, extraImports := findMethods(g.pkg, actorName)
		g.typeConstraints.add(actorMethods)
		fmt.Printf("Actor %s methods: %d\n", actorName, len(actorMethods))
		g.actor2Methods[actorTypeName] = actorMethods
		if extraImports != nil {
			for k := range extraImports {
				g.actorImports[k] = struct{}{}
			}
		}
	}
}

func (g *Generator) importMaps() []map[string]struct{} {
	maps := []map[string]struct{}{g.taskImports, g.actorImports}
	// collect actor method related imports (already captured in findMethods above inside extraImports)
	return maps
}

func (g *Generator) generateCode() string {
	var buf bytes.Buffer
	buf.WriteString(packageCommentsTPL)
	fmt.Fprintf(&buf, "package %s\n\n", g.pkg.Name)
	writeImports(&buf, g.importMaps())

	for _, m := range g.tasks {
		generateWrapperFunction(taskDefTpl, &buf, m, g.typeConstraints.type2ConstraintId, "")
	}
	for _, factory := range g.actorFactories {
		if len(factory.Results) == 0 { // safety
			continue
		}
		actorTypeName := factory.Results[0].Type
		actorName := factory.Name
		generateWrapperFunction(actorDefTpl, &buf, factory, g.typeConstraints.type2ConstraintId, actorName)
		for _, am := range g.actor2Methods[actorTypeName] {
			generateWrapperFunction(actorMethodDefTpl, &buf, am, g.typeConstraints.type2ConstraintId, actorName)
		}
	}
	buf.WriteString(g.typeConstraints.buf.String())
	return buf.String()
}

func (g *Generator) write(code string) error {
	// helpful temporary artifact (keep original side-effect)
	_ = os.WriteFile("/tmp/out.go", []byte(code), 0o644)
	formatted, err := format.Source([]byte(code))
	if err != nil {
		log.Printf("Warning: Could not format generated code: %v", err)
		formatted = []byte(code)
	}
	outputFile := filepath.Join(g.packagePath, generatedFileName)
	formatted, err = imports.Process(outputFile, formatted, nil)
	if err != nil {
		return fmt.Errorf("process imports: %w", err)
	}
	if err := os.WriteFile(outputFile, formatted, 0o644); err != nil {
		return err
	}
	fmt.Printf("Generated wrapper code written to: %s\n", outputFile)
	return nil
}

func findStruct(pkg *packages.Package, commentPatten string) *ast.TypeSpec {
	var targetStruct *ast.TypeSpec
	for _, file := range pkg.Syntax {
		ast.Inspect(file, func(n ast.Node) bool {
			if targetStruct != nil {
				return false
			}

			genDecl, ok := n.(*ast.GenDecl)
			if !ok || genDecl.Tok != token.TYPE {
				return true
			}

			// Check if there's a comment with $raytasksComment
			if genDecl.Doc != nil {
				for _, comment := range genDecl.Doc.List {
					if strings.TrimSpace(comment.Text) == commentPatten {
						for _, spec := range genDecl.Specs {
							if typeSpec, ok := spec.(*ast.TypeSpec); ok {
								if _, ok := typeSpec.Type.(*ast.StructType); ok {
									targetStruct = typeSpec
									return false
								}
							}
						}
					}
				}
			}
			return true
		})
	}
	return targetStruct
}

func writeImports(buf *bytes.Buffer, imports []map[string]struct{}) {
	importSet := make(map[string]struct{})
	importSet[fmt.Sprintf(`"%s/ray"`, workspaceRepo)] = struct{}{}
	importSet[fmt.Sprintf(`. "%s/ray/generic"`, workspaceRepo)] = struct{}{}
	for _, mp := range imports {
		for imp := range mp {
			importSet[imp] = struct{}{}
		}
	}
	if len(importSet) == 0 {
		return
	}
	// deterministic order for stable diffs
	list := make([]string, 0, len(importSet))
	for k := range importSet {
		list = append(list, k)
	}
	sort.Strings(list)
	fmt.Fprintf(buf, "import (\n")
	for _, imp := range list {
		fmt.Fprintf(buf, "\t%s\n", imp)
	}
	fmt.Fprintf(buf, ")\n\n")
}

type Method struct {
	ReceiverType string
	Name         string
	Params       []Param // for variadic, the last param.Type will be the slice element type
	Results      []Result
	IsVariadic   bool
}

type Param struct {
	Name string
	Type string
}

type Result struct {
	Type string
}

func findMethods(pkg *packages.Package, structName string) ([]Method, map[string]struct{}) {
	var methods []Method

	// Get the struct type
	obj := pkg.Types.Scope().Lookup(structName)
	if obj == nil {
		return methods, nil
	}

	named, ok := obj.Type().(*types.Named)
	if !ok {
		return methods, nil
	}

	imports := make(map[string]struct{})
	getTypeName := func(typ types.Type) string {
		pkgPath, typeName := GetPackageAndTypeName(typ)
		if pkgPath != pkg.Types.Path() && len(pkgPath) > 0 {
			imports[fmt.Sprintf(`"%s"`, pkgPath)] = struct{}{}
			typeName = fmt.Sprintf("%s.%s", packageName(pkgPath), typeName)
		}
		return typeName
	}
	// Iterate through all methods
	for i := 0; i < named.NumMethods(); i++ {
		method := named.Method(i)
		if !method.Exported() {
			continue
		}

		sig := method.Type().(*types.Signature)
		m := Method{
			Name: method.Name(),
		}
		// fmt.Printf("method: %v Name: %v\n", method, method.Pkg())
		// fmt.Printf("sig.Recv: %v \n", sig.Recv())
		receiverType := sig.Recv().Type()

		// To get just the "*MyTask" part:
		// If it's a pointer, dereference it to get the named type
		receiverTypeStr := ""
		if ptr, ok := receiverType.(*types.Pointer); ok {
			if named, ok := ptr.Elem().(*types.Named); ok {
				receiverTypeStr = fmt.Sprintf("*%s", named.Obj().Name())
			}
		} else if named, ok := receiverType.(*types.Named); ok {
			// If it's not a pointer, it's already the named type
			receiverTypeStr = named.Obj().Name()
		}
		m.ReceiverType = receiverTypeStr

		// Process parameters
		params := sig.Params()
		for j := 0; j < params.Len(); j++ {
			param := params.At(j)

			paramName := param.Name()
			if paramName == "" {
				paramName = fmt.Sprintf("arg%d", j)
			}

			//paramTypeName = types.TypeString(param.Type(), types.RelativeTo(pkg.Types))
			typeName := getTypeName(param.Type())
			if j == params.Len()-1 && sig.Variadic() {
				// If the last parameter is variadic, remove the [] prefix
				typeName = strings.TrimPrefix(typeName, "[]")
			}
			m.Params = append(m.Params, Param{
				Name: paramName,
				Type: typeName,
			})
		}

		// Check if the last parameter is variadic
		m.IsVariadic = sig.Variadic()

		// Process results
		results := sig.Results()
		for j := 0; j < results.Len(); j++ {
			result := results.At(j)
			m.Results = append(m.Results, Result{
				Type: getTypeName(result.Type()),
			})
		}

		methods = append(methods, m)
	}

	return methods, imports
}

func packageName(pkgPath string) string {
	sep := "/"
	lastIndex := strings.LastIndex(pkgPath, sep)
	if lastIndex == -1 {
		// If separator not found, return the original string as the only element
		return pkgPath
	}
	return pkgPath[lastIndex+len(sep):]
}

// GetPackageAndTypeName 从 types.Type 变量中提取包名和类型名。
// 返回 (包名, 类型名)。如果类型没有显式的包名（例如基本类型或复合类型），包名将为空字符串。
func GetPackageAndTypeName(typ types.Type) (packageName string, typeName string) {
	// 首先检查是否是具名类型 (Named type)，这是最常见的情况，也是唯一有显式包名的情况。
	if named, ok := typ.(*types.Named); ok {
		obj := named.Obj() // 获取定义这个具名类型的 *types.TypeName 对象
		if obj != nil {
			// typeName 是这个类型的名称 (例如 "MyStruct", "Reader")
			typeName = obj.Name()
			// Package() 返回定义这个类型的包，如果类型是预声明的（如 int），则为 nil
			if obj.Pkg() != nil {
				packageName = obj.Pkg().Path() // 包的导入路径 (例如 "fmt", "main")
			}
		}
		return packageName, typeName
	}

	// 接下来处理其他类型的 *types.Type，它们本身没有包名，但有类型名。
	// 对于这些类型，packageName 将为空字符串。
	switch t := typ.(type) {
	case *types.Basic:
		// 基本类型 (int, string, bool 等)
		typeName = t.Name()
		if t.Kind() == types.UnsafePointer {
			packageName = "unsafe"
		}
	case *types.Pointer:
		// 指针类型 (*int, *MyStruct)
		// 类型名是 "ptrTo" + 元素类型名
		// 如果需要更精确的表示，可以递归调用 GetPackageAndTypeName(t.Elem())
		_, elemTypeName := GetPackageAndTypeName(t.Elem())
		typeName = "*" + elemTypeName
	case *types.Slice:
		// 切片类型 ([]int, []MyStruct)
		_, elemTypeName := GetPackageAndTypeName(t.Elem())
		typeName = "[]" + elemTypeName
	case *types.Array:
		// 数组类型 ([N]int, [N]MyStruct)
		_, elemTypeName := GetPackageAndTypeName(t.Elem())
		typeName = fmt.Sprintf("[%d]%s", t.Len(), elemTypeName)
	case *types.Map:
		// 映射类型 (map[string]int)
		_, keyTypeName := GetPackageAndTypeName(t.Key())
		_, elemTypeName := GetPackageAndTypeName(t.Elem())
		typeName = fmt.Sprintf("map[%s]%s", keyTypeName, elemTypeName)
	case *types.Chan:
		// 通道类型 (chan int, chan<- bool)
		_, elemTypeName := GetPackageAndTypeName(t.Elem())
		dir := ""
		switch t.Dir() {
		case types.SendRecv:
			dir = "chan "
		case types.SendOnly:
			dir = "chan<- "
		case types.RecvOnly:
			dir = "<-chan "
		}
		typeName = dir + elemTypeName
	case *types.Signature:
		// 函数或方法签名类型 (func(int) string)
		// 这通常只在需要打印完整的函数签名时有用。
		// 对于包名和类型名，它本身通常不具有一个独立的“名称”。
		// 如果需要表示，可以使用 t.String()。
		typeName = t.String()
	case *types.Struct:
		// 结构体字面量类型 (struct { Field int })
		// 类似于匿名结构体。
		typeName = t.String()
	case *types.Interface:
		// 接口字面量类型 (interface { Method() })
		// 类似于匿名接口。
		typeName = t.String()
	default:
		// 对于其他未知或不常见的类型，使用其 String() 方法作为名称
		typeName = typ.String()
	}

	return packageName, typeName
}

const typeConstraintTpl = `
type T%d interface {
	%s | *Future1[%s] | ray.SharedObject[%s]
}
`

type TypeConstraints struct {
	buf               bytes.Buffer
	type2ConstraintId map[string]int
}

func (t *TypeConstraints) add(methods []Method) {
	for _, method := range methods {
		for _, param := range method.Params {
			if _, ok := t.type2ConstraintId[param.Type]; !ok {
				typeConstraintId := len(t.type2ConstraintId)
				typeConstraint := fmt.Sprintf(typeConstraintTpl, typeConstraintId, param.Type, param.Type, param.Type)
				t.buf.WriteString(typeConstraint)
				t.type2ConstraintId[param.Type] = typeConstraintId
			}
		}
	}
}

/*
	func Echo[any_0 T2](args ...any_0) *RemoteFunc[*Future1[[]any]] {
		_ = (demo).Echo // help you to findStruct the original task
		return NewRemoteFunc[*Future1[[]any]]("Echo", ExpandArgs([]any{}, args))
	}
*/
const taskDefTpl = `
func {{.FuncName}} {{.TypeConstraints}} ( {{.ParamList}} ) *RemoteFunc[*Future{{.ResLen}}{{.ResTypes}}] {
	_ = ({{.ReceiverType}}).{{.FuncName}}  // help you to findStruct the original task
	return NewRemoteFunc[*Future{{.ResLen}}{{.ResTypes}}]("{{.FuncName}}", {{.ArgsStatement}})
}
`

const actorDefTpl = `
type Actor{{.ActorName}} ray.ActorHandle

func {{.FuncName}} {{.TypeConstraints}} ( {{.ParamList}} ) *RemoteActor[Actor{{.ActorName}}] {
	_ = ({{.ReceiverType}}).{{.FuncName}}  // help you to findStruct the original actor constructor
	return NewRemoteActor[Actor{{.ActorName}}]("{{.FuncName}}", []any{n})
}
`

const actorMethodDefTpl = `
func {{.ActorName}}_{{.FuncName}} {{.TypeConstraints}} (actor Actor{{.ActorName}}, {{.ParamList}}) *RemoteFunc[*Future{{.ResLen}}{{.ResTypes}}] {
	_ = ({{.ReceiverType}}).{{.FuncName}}  // help you to findStruct the original actor method
	return NewRemoteFunc[*Future{{.ResLen}}{{.ResTypes}}]("{{.FuncName}}", {{.ArgsStatement}}, ray.ActorHandle(actor))
}
`

type FuncDef struct {
	FuncName        string
	TypeConstraints string
	ParamList       string
	ResLen          int
	ResTypes        string
	ArgsStatement   string
	ReceiverType    string

	ActorName string // only for actor def
}

func generateWrapperFunction(tpl string, buf *bytes.Buffer, method Method, type2ConstraintId map[string]int, actorName string) {
	paramNames := make([]string, len(method.Params))
	paramList := make([]string, len(method.Params))
	typeConstraintList := make([]string, len(method.Params))
	for i, param := range method.Params {
		paramNames[i] = param.Name

		paramTypeName := typeFriendlyName(param.Type)
		paramTypeName = fmt.Sprintf("%s_%d", paramTypeName, i)
		typeConstraintList[i] = fmt.Sprintf("%s T%d", paramTypeName, type2ConstraintId[param.Type])

		if i == len(method.Params)-1 && method.IsVariadic {
			// For variadic parameter, we need to remove the [] prefix
			paramList[i] = fmt.Sprintf("%s ...%s", param.Name, paramTypeName)
		} else {
			paramList[i] = fmt.Sprintf("%s %s", param.Name, paramTypeName)
		}
	}
	typeConstraints := strings.Join(typeConstraintList, ", ")
	if len(typeConstraints) > 0 {
		typeConstraints = fmt.Sprintf("[%s]", typeConstraints)
	}

	resTypes := make([]string, len(method.Results))
	for i, res := range method.Results {
		resTypes[i] = res.Type
	}
	resTypesStr := ""
	if len(resTypes) > 0 { // Future0 has no generic type
		resTypesStr = fmt.Sprintf("[%s]", strings.Join(resTypes, ", "))
	}

	argsStatement := fmt.Sprintf("[]any{%s}", strings.Join(paramNames, ", "))
	if method.IsVariadic {
		argsStatement = fmt.Sprintf(
			"ExpandArgs([]any{%s}, %s)",
			strings.Join(paramNames[:len(paramNames)-1], ", "),
			paramNames[len(paramNames)-1],
		)
	}

	funcDef := FuncDef{
		FuncName:        method.Name,
		TypeConstraints: typeConstraints,
		ParamList:       strings.Join(paramList, ", "),
		ResLen:          len(method.Results),
		ResTypes:        resTypesStr,
		ArgsStatement:   argsStatement,
		ReceiverType:    method.ReceiverType,
		ActorName:       actorName,
	}

	tmpl, err := template.New("funcDef").Parse(tpl)
	if err != nil {
		panic(err)
	}
	err = tmpl.Execute(buf, funcDef)
	if err != nil {
		panic(err)
	}
}

// 将 Go 类型名转换为更友好的标识符名称
// 例如：[]T -> sliceOfT; *T -> pointerOfT; map[K]V -> mapK2V; [n]T -> arrNT; ...
var (
	arrayRegex = regexp.MustCompile(`\[(\d+)\]`)
	mapRegex   = regexp.MustCompile(`map\[([^\]]+)\](.*)`)
	cleanRegex = regexp.MustCompile(`[^a-zA-Z0-9_]`)
)

func typeFriendlyName(typ string) string { // pure helper
	typ = strings.ReplaceAll(typ, "*", "pointerOf")
	typ = strings.ReplaceAll(typ, "[]", "sliceOf")
	typ = arrayRegex.ReplaceAllString(typ, "arr${1}Of")   // [n]T -> arrNT
	typ = mapRegex.ReplaceAllString(typ, "map${1}To${2}") // map[K]V -> mapKToV
	typ = strings.ReplaceAll(typ, "chan<-", "sendChanOf")
	typ = strings.ReplaceAll(typ, "<-chan", "recvChanOf")
	typ = strings.ReplaceAll(typ, "chan ", "chanOf")
	if strings.HasPrefix(typ, "func(") {
		typ = strings.ReplaceAll(typ, "func(", "funcWith")
		typ = strings.ReplaceAll(typ, ")", "")
	}
	typ = strings.ReplaceAll(typ, "interface{}", "any") // interface{} -> any
	typ = strings.ReplaceAll(typ, " ", "_")
	typ = strings.ReplaceAll(typ, ".", "_")
	// only keep alphanumeric + '_' chars
	typ = cleanRegex.ReplaceAllString(typ, "")
	return typ
}
