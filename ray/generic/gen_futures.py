import os
import string

max_returns_len = 16
here_dir = os.path.dirname(os.path.abspath(__file__))
out_file = os.path.join(here_dir, "futures.go")

preamble = """\
// Generated file. DO NOT EDIT.
//
// This file was generated by `python3 gen_futures.py`.
package generic

import (
	"errors"

	"github.com/ray4go/go-ray/ray"
)

// FutureN is a future that represents the result of a ray remote function call with N returns.

// Future0

type Future0 struct {
	obj *ray.ObjectRef
}

func (f *Future0) setObjectRef(obj *ray.ObjectRef) {
	f.obj = obj
}

func (f *Future0) Get() error {
	_, err := f.obj.GetAll()
	return err
}

// Future1

type Future1[T any] struct {
	obj *ray.ObjectRef
}

func (f *Future1[T]) setObjectRef(obj *ray.ObjectRef) {
	f.obj = obj
}

func (f *Future1[T]) Get() (T, error) {
	r, err := f.obj.GetAll()
	return r[0].(T), err
}

type FutureExt1 struct {
	Future1[error]
}

func (f *FutureExt1) Result() error {
	bizErr, rayErr := f.Get()
	return errors.Join(rayErr, bizErr)
}
"""


# future表示一次函数在ray上异步执行的返回值，Get()可以等待函数运行完成并获取其返回值，同时返回值中还加入了一个新的error类型的返回值，用于表示框架执行过程中是否发生了错误。
# 如果用户的函数返回值也包含error类型，为了不让用户在代码中处理多个error，在future引入了一个新的方法Result()，它会将用户函数返回值中的error和框架执行过程中的error合并成一个error返回。
# 生成的代码如下
"""
type Future2[T0 any, T1 any] struct {
	obj *ray.ObjectRef
}

func (f *Future2[T0, T1]) setObjectRef(obj *ray.ObjectRef) {
	f.obj = obj
}

func (f *Future2[T0, T1]) Get() (T0, T1, error) {
	r, err := f.obj.GetAll()
	return r[0].(T0), r[1].(T1), err
}

type FutureExt2[T0 any, T1 any] struct {
	Future2[T0, error]
}

func (f *FutureExt2[T0, T1]) Result() (T0, error) {
	r0, bizErr, rayErr := f.Get()
	return r0, errors.Join(bizErr, rayErr)
}
"""


_future_tpl = """
// Future${l}

type Future${l}[${type_decls}] struct {
	obj *ray.ObjectRef
}

func (f *Future${l}[${types}]) setObjectRef(obj *ray.ObjectRef) {
	f.obj = obj
}

func (f *Future${l}[${types}]) Get() (${types}, error) {
	r, err := f.obj.GetAll()
	return ${ret_asserts}, err
}

type FutureExt${l}[${type_decls}] struct {
	Future${l}[${types_ext}, error]
}

func (f *FutureExt${l}[${types}]) Result() (${types_ext}, error) {
	${ret_names_ext}, bizErr, rayErr := f.Get()
	return ${ret_names_ext}, errors.Join(bizErr, rayErr)
}
"""
future_tpl = string.Template(_future_tpl)

def gen_future(num_returns: int):
    assert num_returns >= 2
    l = num_returns
    
    types = ', '.join(f"T{i}" for i in range(l))  # T0, T1, ..., Tn
    type_decls = ', '.join(f"T{i} any" for i in range(l))  # T0 any, T1 any, ..., Tn any
    types_ext = ', '.join(f"T{i}" for i in range(l-1))  # T0, T1, ..., Tn-1
    ret_asserts = ', '.join(f"r[{i}].({T})" for i, T in enumerate(types.split(', ')))  # r[0].(T0), r[1].(T1),..., r[n].(Tn)
    ret_names_ext = ', '.join(f"r{i}" for i in range(l-1))  # r0, r1,..., rn-1

    return future_tpl.substitute(dict(
        l=l, types=types, type_decls=type_decls, types_ext=types_ext,
        ret_asserts=ret_asserts, ret_names_ext=ret_names_ext,
    ))

with open(out_file, "w") as f:
    f.write(preamble)
    for i in range(2, max_returns_len+1):
        f.write(gen_future(i))



