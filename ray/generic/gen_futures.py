import os
import string

max_returns_len = 15
ray_max_get_num = 5
here_dir = os.path.dirname(os.path.abspath(__file__))
out_file = os.path.join(here_dir, "futures.go")

preamble = """\
// Generated file. DO NOT EDIT.
//
// This file was generated by `python3 gen_futures.py`.
// FutureN is a future that represents the result of a ray remote function call with N returns.
package generic

import (
	"github.com/ray4go/go-ray/ray"
)

type Future0 struct {
	obj *ray.ObjectRef
}

func (f *Future0) setObjectRef(obj *ray.ObjectRef) {
	f.obj = obj
}

func (f *Future0) Get(options ...ray.GetObjectOption) error {
	return ray.Get0(f.obj, options...)
}
"""


# future表示一次函数在ray上异步执行的返回值，Get()可以等待函数运行完成并获取其返回值，同时返回值中还加入了一个新的error类型的返回值，
# 用于表示框架执行过程中是否发生了错误。生成的代码如下
"""
type Future2[T0 any, T1 any] struct {
	obj *ray.ObjectRef
}

func (f *Future2[T0, T1]) setObjectRef(obj *ray.ObjectRef) {
	f.obj = obj
}

func (f *Future2[T0, T1]) Get(options ...ray.GetObjectOption) (T0, T1, error) {
	return ray.Get2[T0, T1](f.obj, options...)
}
"""


_future_tpl = """
type Future${l}[${type_decls}] struct {
	obj *ray.ObjectRef
}

func (f *Future${l}[${types}]) setObjectRef(obj *ray.ObjectRef) {
	f.obj = obj
}

func (f *Future${l}[${types}]) Get(options ...ray.GetObjectOption) (${types}, error) {
	return ${prefix}Get${l}[${types}](f.obj, options...)
}
"""
future_tpl = string.Template(_future_tpl)

future1_extra = """
// ObjectRef returns the underlying ObjectRef of the Future.
// Used for passing the Future to a remote task / actor method call.
func (f *Future1[T0]) ObjectRef() *ray.ObjectRef {
	return f.obj
}
"""


def gen_future(num_returns: int):
    assert num_returns >= 1
    l = num_returns

    types = ", ".join(f"T{i}" for i in range(l))  # T0, T1, ..., Tn
    type_decls = ", ".join(f"T{i} any" for i in range(l))  # T0 any, T1 any, ..., Tn any
    defs = future_tpl.substitute(
        dict(
            l=l,
            types=types,
            type_decls=type_decls,
            prefix="ray." if l <= ray_max_get_num else "",
        )
    )
    if l == 1:
        defs += future1_extra
    return defs


with open(out_file, "w") as f:
    f.write(preamble)
    for i in range(1, max_returns_len + 1):
        f.write(gen_future(i))
